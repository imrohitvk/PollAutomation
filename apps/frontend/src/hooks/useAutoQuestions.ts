import { useState, useEffect, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

interface AutoGeneratedQuestion {
  id: string;
  type: 'multiple_choice' | 'true_false' | 'short_answer';
  difficulty: 'easy' | 'medium' | 'hard';
  questionText: string;
  options?: string[];
  correctIndex?: number;
  correctAnswer?: string;
  explanation: string;
}

interface QuestionSegment {
  segmentId: string;
  segmentNumber: number;
  questions: AutoGeneratedQuestion[];
  summary: string;
  generatedAt: Date;
}

interface UseAutoQuestionsProps {
  meetingId: string;
  enabled: boolean;
}

export const useAutoQuestions = ({ meetingId, enabled }: UseAutoQuestionsProps) => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [questionSegments, setQuestionSegments] = useState<QuestionSegment[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [lastGeneratedSegment, setLastGeneratedSegment] = useState<number | null>(null);

  // Initialize Socket.IO connection
  useEffect(() => {
    if (!enabled || !meetingId) return;

    console.log('ðŸ”Œ [AUTO-QUESTIONS] Connecting to Socket.IO for real-time question updates');

    const token = localStorage.getItem('token');
    if (!token) {
      console.error('âŒ [AUTO-QUESTIONS] No auth token found');
      return;
    }

    const newSocket = io(import.meta.env.VITE_BACKEND_URL || 'http://localhost:8000', {
      auth: { token },
      autoConnect: true
    });

    newSocket.on('connect', () => {
      console.log('âœ… [AUTO-QUESTIONS] Connected to Socket.IO');
      setIsConnected(true);
      
      // Join the meeting room to receive question events
      newSocket.emit('join-meeting', meetingId);
      console.log(`ðŸ  [AUTO-QUESTIONS] Joined meeting room: ${meetingId}`);
    });

    newSocket.on('disconnect', () => {
      console.log('âŒ [AUTO-QUESTIONS] Disconnected from Socket.IO');
      setIsConnected(false);
    });

    newSocket.on('connect_error', (error) => {
      console.error('âŒ [AUTO-QUESTIONS] Socket connection error:', error);
    });

    // Listen for auto-generated questions
    newSocket.on('questionsGenerated', (data) => {
      console.log(`ðŸŽ¯ [AUTO-QUESTIONS] Questions generated for Segment ${data.segmentNumber}`);
      console.log('ðŸ“‹ [AUTO-QUESTIONS] Questions data:', data);

      const newSegment: QuestionSegment = {
        segmentId: data.segmentId,
        segmentNumber: data.segmentNumber,
        questions: data.questions,
        summary: data.summary,
        generatedAt: new Date(data.generatedAt)
      };

      setQuestionSegments(prev => {
        // Check if segment already exists (avoid duplicates)
        const existingIndex = prev.findIndex(seg => seg.segmentId === data.segmentId);
        if (existingIndex >= 0) {
          const updated = [...prev];
          updated[existingIndex] = newSegment;
          return updated;
        } else {
          return [...prev, newSegment].sort((a, b) => a.segmentNumber - b.segmentNumber);
        }
      });

      setLastGeneratedSegment(data.segmentNumber);
    });

    setSocket(newSocket);

    return () => {
      console.log('ðŸ”Œ [AUTO-QUESTIONS] Cleaning up Socket.IO connection');
      newSocket.disconnect();
    };
  }, [meetingId, enabled]);

  // Fetch existing questions when component mounts
  const fetchExistingQuestions = useCallback(async () => {
    if (!meetingId) return;

    try {
      console.log('ðŸ“š [AUTO-QUESTIONS] Fetching existing questions for meeting:', meetingId);
      
      const response = await fetch(`/api/segments/${meetingId}/questions`);
      if (response.ok) {
        const data = await response.json();
        
        const segments: QuestionSegment[] = data.questionsBySegment.map((item: any) => ({
          segmentId: item.segmentId,
          segmentNumber: item.segmentNumber,
          questions: item.questions,
          summary: item.summary,
          generatedAt: new Date(item.generatedAt)
        }));

        setQuestionSegments(segments);
        console.log(`ðŸ“š [AUTO-QUESTIONS] Loaded ${segments.length} existing question segments`);
      }
    } catch (error) {
      console.error('âŒ [AUTO-QUESTIONS] Error fetching existing questions:', error);
    }
  }, [meetingId]);

  useEffect(() => {
    if (enabled) {
      fetchExistingQuestions();
    }
  }, [enabled, fetchExistingQuestions]);

  // Get total question count across all segments
  const getTotalQuestionCount = useCallback(() => {
    return questionSegments.reduce((total, segment) => total + segment.questions.length, 0);
  }, [questionSegments]);

  // Get questions for a specific segment
  const getQuestionsForSegment = useCallback((segmentNumber: number) => {
    return questionSegments.find(seg => seg.segmentNumber === segmentNumber);
  }, [questionSegments]);

  // Clear all questions (for session reset)
  const clearQuestions = useCallback(() => {
    console.log('ðŸ§¹ [AUTO-QUESTIONS] Clearing all questions');
    setQuestionSegments([]);
    setLastGeneratedSegment(null);
  }, []);

  return {
    questionSegments,
    isConnected,
    lastGeneratedSegment,
    getTotalQuestionCount,
    getQuestionsForSegment,
    clearQuestions,
    socket
  };
};

export default useAutoQuestions;